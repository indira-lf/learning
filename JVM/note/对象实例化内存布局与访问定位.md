# 对象的实例化

## 创建的方式

- new
- Class的newInstance()：反射的方式，只能调用空参的构造器，权限必须是public
- Constructor的newInstance()：反射的方式，可以调用空参、带参的构造器，权限没有要求
- 使用clone()：当前类需要实现Cloneable接口，实现clone()，浅克隆
- 使用反序列化：从文件、网络中获取一个对象的二进制流
- 第三方库Objenesis

## 创建对象的步骤

-  1、**判断对象对应的类是否加载、链接、初始化** 

-  2、**为对象分配内存** ：首先计算对象占用空间大小，接着在堆中划分一块内存给新对象，如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。

- - 如果内存规整----指针碰撞


  - 如果内存不完整 
  - - 虚拟机要维护一个列表
    - 空闲列表分配
  - 说明：具体得看采用哪种垃圾收集器

-  3、处理并发安全问题

- - 采用CAS配上失败重试保证更新的原子性
  - 每个线程预先分配一块TLAB---通过-XX:+/-UseTLAB参数来设定

-  4、初始化分配到的空间---所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用

-  5、设置对象的对象头

-  6、执行init方法进行初始化

---

步骤一：虚拟机遇到一条new指令，首先去检查这个指令的参数是否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象。

> 指针碰撞：
>
> > 所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的显示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般带有compact过程的收集器时，使用指针碰撞。
>
> 空闲列表分配：
>
> > 如果内存是不完整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。
> >
> > 意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为“空闲列表”

# 对象的内存布局



# 对象的访问定位

