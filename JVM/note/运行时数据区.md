# 程序计数器（PC寄存器）

## 介绍

JVM中的程序计数器中，Register的命名源于CPU的的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能被运行。

这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器会更加贴切，并且也不容易引起一些不必要的误会。==JVM中的PC寄存器是对物理寄存器的一种抽象模拟。== 

## 作用

PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。

![PC寄存器](../img/PC寄存器.png)

在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。

唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。

## 举例说明

![PCRegisterTest](../img/PCRegisterTest.png)

红框：偏移地址或指令地址，PC寄存器中所存储的结构

蓝框：操作指令

## 两个常见问题

==使用PC寄存器存储字节指令地址有什么用呢？==

==为什么使用PC寄存器记录当前线程的执行地址呢？== 

因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。

JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。



==PC寄存器为什么会被设定为线程私有？== 

**为了能够准确地记录各个线程在执行过程的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器** ，这样一来各个线程之间便可以进行独立计算，从而不会出现互相干扰的情况。

由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。

这样必然导致经常中断或恢复，如何保证分毫不差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

> CPU时间片：CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。
>
> > 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行
> >
> > 在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。



# 虚拟机栈

## 虚拟机栈概述

**优点：** 跨平台，指令集小，编译器容易实现

**缺点：** 性能下降，同样实现的功能需要更多的指令

**作用：** 

- 主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法空的调用和返回。
- 局部变量 vs 成员变量（或属性）
- 基本数据变量 vs 引用类型变量（类、数组、接口）

## 栈的存储单位



## 局部变量表



## 操作数栈



## 代码追踪



## 栈顶缓存技术



## 动态链接



## 方法的调用：解析与分派



## 方法返回地址



## 一些附加信息



## 栈的相关面试题





