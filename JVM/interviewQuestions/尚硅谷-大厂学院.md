# 字节码篇

## 什么是字节码指令(byte code)？

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的==操作码== (opcode)以及跟随其后的零至多个代表此操作所需参数的==操作数== (operand)所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。

## 文件结构有几个部分？

Class文件的总体结构如下：

- 魔数
- Class文件版本
- 常量池
- 访问标识（或标志）
- 类索引，父类索引，接口索引集合
- 字段表集合
- 方法表集合
- 属性表集合

## Class文件的魔数是什么？

class文件的标识

- 每个Class文件开头的4个字节的无符号整数称为魔数（magic Number)。
- 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的Class文件，即：魔数是Class文件的标识符。
- 魔数值固定为0xCAFEBABE，不会改变。
- 如果Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出错误。
- 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意改动。

## 如何确保高版本的JVM可执行低版本的class文件？

- 版本号和Java编译器的对应关系如下表：

| 主版本（十进制） | 副版本（十进制） | 编译器版本 |
| -------- | -------- | ----- |
| 45       | 3        | 1.1   |
| 46       | 0        | 1.2   |
| 47       | 0        | 1.3   |
| 48       | 0        | 1.4   |
| 49       | 0        | 1.5   |
| 50       | 0        | 1.6   |
| 51       | 0        | 1.7   |
| 52       | 0        | 1.8   |
| 53       | 0        | 1.9   |
| 54       | 0        | 1.10  |
| 55       | 0        | 1.11  |

- Java的版本号是从45开始的，JDK1.1以后的每个JDK大版本发布主版本号向下兼容

## 常量池：class文件的基石？作用是？

### 为什么需要常量池计数器？

constant_pool_count（常量池计数器）

- 由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池计数值。
- 常量池容量计数值（u2类型）：从1开始，表示常量池中有多少项常量。即constant_pool_count=1表示常量池中有0个常量项。

### 常量池表

- constant_pool是一种表结构，以1~constant_pool_count-1为索引。表明了后面有多少个常数项。
- 常量池主要存放两大类常量：==字面量（Literal）== 和==符号引用（Symbolic Reference）== 
- 它包含了class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中每一项都具备相同的特征。第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte（标记字节、标签字节）

#### 字面量和符号引用

| 常量   | 具体的常量        |
| ---- | ------------ |
| 字面量  | 文本字符串        |
|      | 声明为final的常量值 |
| 符号引用 | 类和接口的全限定名    |
|      | 指定的名称和描述符    |
|      | 方法的名称和描述符    |

#### 谈谈你对符号引用、直接引用的理解？

Java代码在进行编译Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而不是虚拟机加载Class文件的时候进行动态链接。也就是说，==虚拟机在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。 当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建或运行时被解析、编译到具体的内存地址之中。== 

符号引用和直接引用的区别与关联：

- 符号引用：符号引用以==一组符号== 来描述引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。==符号引用与虚拟机实现的内存布局无关== ，引用的目标并不一定已经加载到内存中。
- 直接引用：直接引用可以是直接==指向目标的指针、相关偏移量或一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的== ，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。

## 访问标识

- 在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或接口层次的访问信息，包括：
- - 这个Class是类还是接口；
  - 是否定义为public类型；
  - 是否定义为abstract类型；
  - 如果是类的话，是否被声明为final等；

| 标志名称           | 标志值    | 含义                                       |
| -------------- | ------ | ---------------------------------------- |
| ACC_PUBLIC     | 0x0001 | 标志为public类型                              |
| ACC_FINAL      | 0x0010 | 标志被声明为final，只有类可以设置                      |
| ACC_SUPER      | 0x0020 | 标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真（使用增强的方法调用父类方法） |
| ACC_INTERFACE  | 0x0200 | 标志这是一个接口                                 |
| ACC_ABSTRACT   | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，此标志为真，其他类型为假   |
| ACC_SYNTHETIC  | 0x1000 | 标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）         |
| ACC_ANNOTATION | 0x2000 | 标志这是一个注解                                 |
| ACC_ENUM       | 0x4000 | 标志这是一个枚举                                 |

- 类的访问权限通常为ACC_开头的常量。

## 类索引、父类索引、接口索引集合

- 在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：

| 长度   | 含义                         |
| ---- | -------------------------- |
| u2   | this_class                 |
| u2   | super_class                |
| u2   | interface_class            |
| u2   | interface[interface_count] |

- 这三项用来确定这个类的继承关系。
- - **类索引** 用于确定这个类的全限定名；
  - **父类索引用** 于确定这个类的父类的权限的名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0；
  - **接口索引** 集合就用来描述这个类实现了哪些接口，这些被实现的接口按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。

## 字段表集合

fields

- 用于描述接口或类中声明的变量。字段（field）包括==类级别以及实例级变量== ，但是不包括方法内部、代码块内部声明的局部变量。
- 字段用什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。
- 它指向常量池索引集合，它描述了每个字段的完整信息。比如==字段的标识符、访问修饰符（public、private或protected）、是类变量还是实例变量（static修饰符）、是否是常量（final修饰符）== 等

注意事项：

- 字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性有，会自动添加指向外部类实例的字段。
- 在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。

### 字段计数器（fields_count）

fields_count的值表示当前class文件fields表的成员个数。使用两个字节表示。

fields表中每个成员都是一个fields_info结构，用于表示该类或接口所有类字段或实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。

### 字段表

- fields表中的每个成员变量都必须是一个fields_info结构的数据项，用于表示当前类或者接口中某个字段的完整描述。
- 一个字段的信息包括这些信息。这些信息中，==各个修饰符都是布尔值，要么有，要么没有。== 
- - 作用域（public、private、protected修饰符）
  - 是实例变量还是类变量（static修饰）
  - 可变性（final）
  - 并发可见性（volatile修饰符，是否强制从主内存读写）
  - 可否序列化（transient修饰符）
  - 字段数据类型（基本数据类型、对象、数组）
  - 字段名称

## 方法表集合

methods：指向常量池索引集合，它完整描述了每个方法的签名。

- 一个字节码文件中，==每个methods_info项都对应着一个类或者接口中的方法信息。== 比如方法的访问修饰符，方法的返回值类型以及方法的参数信息等。
- 如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来。
- 一方面，methods表只描述当前类或接口中声明的方法，==不包括从父类或父接口继承的方法== 。另一方面，methods表有可能会出来编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：==类（接口）初始化方法<clinit>()和实例初始化方法<init>()）。

使用注意事项：

​	在Java语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字符符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在Class文件格式中，特征签名的范围更大一些，只要描述不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。

## 知道字节码吗？字节码指令由哪些？

按用途大致分为9类：

- 加载与存储指令
- 算术指令
- 类型转换指令
- 对象的创建与访问指令
- 方法调用与返回指令
- 操作数栈管理指令
- 控制转移指令
- 异常处理指令
- 同步控制指令