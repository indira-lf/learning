# 上篇

## 基础篇

### 网络基础

#### TCP三次握手

##### OSI与TCP/IP模型



##### 常见网络服务分层



##### TCP与UDP区别及场景



##### TCP滑动窗口，拥塞控制



##### TCP粘包原因和解决方法



##### TCP、UDP报文格式



#### HTTP协议

##### HTTP协议1.0_1.1_2.0



##### HTTP与HTTPS之间的区别



##### Get与Post请求区别



##### HTTP常见响应状态码



##### 重定向与转发区别



##### Cookie和Session区别



#### 浏览器输入URL过程



### 操作系统基础

#### 进程和线程的区别

##### 进程间通信方式IPC



##### 用户态和核心态



##### 操作系统的进程空间



#### 操作系统内存管理

##### 页面置换算法FIFO、LRU



##### 死锁条件、解决方式



### Java基础

#### 面向对象三大特性

##### Java与C++区别



##### 多态实现原理



##### static和final关键字



##### 抽象类和接口



##### 泛型以及泛型擦除



##### 反射原理以及使用场景



##### Java异常体系



#### 数据结构

##### ArrayList和LinkedList



##### List遍历快速和安全失败



##### 详细介绍HashMap



##### ConcurrentHashMap



##### String

#### 设计模式

##### 单例模式



##### 工厂模式



##### 抽象工厂模式



### 面试题

#### 构造方法



#### 初始化块



#### This



#### 重写和重载的区别



#### Object类方法



#### 基本数据类型和包装类



## JVM篇

### JVM内存划分

#### JVM运行时数据区域



#### 堆内存分配策略



#### 创建一个对象的步骤



#### 对象引用



### JVM类加载过程

#### 双亲委派机制



#### Tomcat的类加载机制



### JVM垃圾回收

#### 存活算法和两次标记过程



#### 垃圾回收算法

##### MinorGC、MajorGC、FullGC



#### 垃圾收集器



#### 配置垃圾收集器



#### JVM性能调优



#### JDK新特性



### 线上故障排查

#### 硬件故障排查



#### 报表异常|JVM调优



#### 大屏异常|JUC调优



#### 接口延迟|SWAP调优



#### 内存溢出|SWAP调优



#### CPU飚高|死循环



## 多线程篇

###  线程调度

#### 线程状态



#### 线程状态切换



#### 阻塞唤醒过程



#### wait和sleep区别



#### 创建线程方式



### 线程池

#### 线程池构造函数



#### 线程处理任务过程



#### 线程拒绝策略



#### Executor类实现线程池



#### 线程池大小设置



### 线程安全

#### 乐观锁，CAS思想



#### synchronized底层实现原理



#### ReentrantLock底层实现



#### 公平锁和非公平锁区别



#### 使用层面锁优化



#### 系统层面锁优化



#### ThreadLocal原理



#### HashMap线程安全



#### String不可变原因



### 内存模型

#### volatile底层实现



#### AQS思想



#### happens-before



## MySQL篇

### WhyMySQL？

#### 海量Aerospike



#### 图谱Neo4j



#### 文档MongoDB



#### 云存储



#### FastDFS



### 事务

#### 事务4大特性



#### 事务隔离级别



#### 默认隔离级别-RR



#### RR和RC使用场景



#### 行锁，表锁，意向锁



#### MVCC多版本并发控制



### 索引

#### InnoDB和MyIsam引擎



#### 哈希索引



#### B+树索引



#### 创建索引



#### 聚簇索引和非聚簇索引



#### 最左前缀问题



### SQL查询

#### SQL语句的执行过程



#### 回表查询和覆盖索引



#### Explain及优化



#### JOIN查询



### 集群

#### 主从复制过程



#### 数据一致性问题



#### 集群架构



#### 故障转移和恢复



### 面试题

#### 分库分表

##### 如何分库分表



#### 如何将老数据进行迁移



#### 系统性能的评估及扩展



#### 如何生成自增的id主键



### 线上故障及优化

#### 更新失败|主从同步延时



#### 应用崩溃|分库分表优化



#### 查询异常|SQL调优



## Redis篇

### WhyRedis？

#### 简单高效



#### Memcache



#### Tair



#### Guava



#### EVCache



#### ETCD



### Redis底层

#### redis数据类型



#### 相关API



#### redis底层结构



#### Zset底层实现



### Redis可用性

#### redis持久化



#### redis事务



#### redis失效策略



#### redis读写模式



#### 多级缓存



### Redis七大经典问题

#### 缓存雪崩



#### 缓存穿透



#### 缓存击穿



#### 数据不一致



#### 数据并发竞争



#### 热点Key问题



#### BigKey问题



### Redis分区容错

#### redis数据分区



#### 主从模式=简单



#### 哨兵模式=读多



#### 集群模式=写多



#### 分布式锁



#### redis心跳检测



### Redis实战

#### redis优化



#### redis热升级



## Kafka篇

















