# 创建型模式

## 单例(Singleton)模式

==一个单一的类，负责创建自己的对象，同时确保系统中只有单个被创建。== 

**单例特点：** 

- 某个类只能有一个实例；（构造器私有）
- 它必须自行创建这个实例；（自己编写实例化逻辑）
- 它必须自行向整个系统提供这个实例；（对外提供实例化方法）

![单例模式](../img/单例模式.png)

**应用场景**

- 什么场景用到？
- - 多线程中的线程池
  - 数据库的连接池
  - 系统环境信息
  - 上下文（ServletContext）
- 面试问题
- - 系统环境信息（System.getProperties()）？
  - Spring中怎么保持组件单例的？
  - ServletContext是什么？是单例吗？怎么保证？
  - ApplicationContext是什么？是单例吗？怎么保证？
  - 数据库连接池一般怎么创建出来的，怎么保证单实例？


## 原型(Prototype)模式

==原型模式是用于创建重复的对象，同时又能保证性能。== 

![原型模式](../img/原型模式.png)



## 工厂(Factory)模式

==工厂模式提供了一种创建对象的最佳方式。我们不必关心对对象的创建细节，只需根据不同情况获取不同产品即可。== 

### 简单工厂模式

三个角色：

- Factory：工厂模式，WuLinFactory
- Product：抽象产品角色，Car
- ConcreteProduct：具体产品角色，VanCar、MiniCar

![工厂模式-简单工厂](../img/工厂模式-简单工厂.png)

### 工厂方法



![工厂模式-工厂方法](../img/工厂模式-工厂方法.png)

### 抽象工厂

![工厂模式-抽象工厂](../img/工厂模式-抽象工厂.png)



## 建造者(Builder)模式

产品角色（Product）：Phone

抽象者模式（Builder）：AbstractPhoneBuilder

具体建造者（Concrete Builder）：PhoneBuilder



> 链式调用：将void修改成AbstractPhoneBuilder

![建造者模式](../img/建造者模式.png)



# 结构型模式

## 适配器(Structural Pattern)模式

- 将==一个接口转换== 成客户希望的==另一个接口== ，适配器模式使接口不兼容的那些类可以一起工作，适配器模式分为类结构型模式（继承）和对象结构型模式（组合）两种，前者（继承）类之间的耦合度比之后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对比较少些。
- 别名也可以是Wrapper，包装器



适配器模式（Adapter）包含以下主要角色。

- 目标（Target）接口：可以是抽象类或接口，客户希望直接用的接口
- 适配者（Adaptee）类：隐藏的转换接口
- 适配器（Adapter）类：它是一个转换器，突然继承或引用适配器的对象，把适配者接口转换成目标接口。



![适配器模式](../img/适配器模式.png)



## 桥接模式（Bridge Pattern）

- ==将抽象与实现解耦，使两者都可以独立变化。== 
- 在现象生活中，某些类具有两个或多个维度的变化，如图形可以按形状分，又可以按颜色分。如何设置类似于PS这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m种形状和n种颜色的图形就有m*n种，不但对应的子类很多，而且扩展困难。不同颜色和字体的文字，不同品牌和功率的汽车。
- ==桥接将继承转为关联，降低类之间的耦合度，减少代码量。== 
- 桥接模式包含以下主要角色：
- - 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
  - 扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
  - 实现化（Implementor）角色：定义实现化角色的定义，供扩展抽象化角色调用。
  - 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。

![桥接模式](../img/桥接模式.png)



## 装饰器模式（Decorator/Wrapper Pattern）

- 适配器是连接两个类，==可以增强一个类，装饰器是增强一个类== 
- 向一个现有的对象添加新功能，同时又不改变其结构。属于对象结构型模式
- 创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能

![装饰器模式](../img/装饰器模式.png)



## 代理模式（Proxy Pattern）

- 代理模式，给某一个对象提供一个代理，并由==代理对象控制对原对象的引用== ，对象结构型模式。这种也是静态代理。

![代理模式](../img/代理模式.png)



## 组合模式（Composite Pattern）

- 把一组相似的对象当作一个单一的对象。如：树形菜单

![组合模式](../img/组合模式.png)



## 外观模式（Facade Pattern）

- 外观模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。

![外观模式](../img/外观模式.png)

## 享元模式（Flyweight Pattern）

- 享元模式，运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。对象结构型
- 在享元模式中==可以共享的相同内容称为内部状态（IntrinsicState）== ，而那些需要外部环境来设置的==不能共享的内容称为外部状态（Extrinsic State）== ，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。
- 在享元模式中通常会出现工厂模式，需要创建一个==享元工厂来负责维护一个享元池（Flyweight Pool）== 用于存储具有相同内部状态的享元对象。
- 包括的角色
- - Flyweight：抽象享元类
  - ConcreteFlyweight：具体享元类
  - UnsharedConcreteFlyweight：非共享具体享元类
  - FlyweightFactory：享元工厂类

![享元模式](../img/享元模式.png)



# 行为型模式

## 模板方法（Template Method）

- 在模板模式中，一个抽象类公开定义了执行它的方法的方式模板。它的子类可以按需要重写方法实现，但调用将以抽象类中的定义方式进行。
- 包含角色
- - 抽象类/抽象模板(Abstract Class)
  - 具体实现子类/具体实现(Concrete Class)

![模板方法](../img/模板方法.png)

## 策略（Strategy）模式

- 策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。属于对象行为模式。
- 主要角色：
- - 抽象策略类：公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。
  - 具体策略类：实现了抽象策略定义的接口，提供具体的算法实现。
  - 环境类：持有一个策略类的引用，最终给客户端调用。

![策略模式](../img/策略模式.png)

## 状态（State）模式

- 对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。
- 主要角色：
- - 环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。
  - 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。
  - 具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。

![状态模式](../img/状态模式.png)

## 中介者（Mediator）模式

- 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，减少对象间混乱的依赖关系，从而使其耦合松散，而且可以独立地改变它们之间的交互。对象行为型模式。
- 角色：
- - Mediator：抽象中介者
  - ConcreteMediator：具体中介者
  - Colleague：抽象同事类
  - ConcreteColleague：具体同事类

![中介者模式](../img/中介者模式.png)

